{"ast":null,"code":"// 카드 속성 비교 함수\nexport const compareAttributes = cards => {\n  if (cards.length !== 3) {\n    return {\n      isValid: false,\n      message: '3개의 카드가 필요합니다.'\n    };\n  }\n  const attributes = ['race', 'job', 'alignment'];\n  let isValidCombination = true;\n  for (const attr of attributes) {\n    const values = [cards[0][attr], cards[1][attr], cards[2][attr]];\n    const allSame = values.every(v => v === values[0]);\n    const allDifferent = new Set(values).size === values.length;\n    if (!allSame && !allDifferent) {\n      isValidCombination = false;\n      break;\n    }\n  }\n  return {\n    isValid: isValidCombination,\n    message: isValidCombination ? '유효한 조합입니다!' : '유효하지 않은 조합입니다.'\n  };\n};\n\n// 카드 ID로부터 속성 결정\nexport const getCardAttributes = id => {\n  // 종족 결정\n  let race;\n  if ([1, 2, 3, 10, 11, 12, 19, 20, 21].includes(id)) {\n    race = 'human';\n  } else if ([4, 5, 6, 13, 14, 15, 22, 23, 24].includes(id)) {\n    race = 'elf';\n  } else {\n    race = 'dwarf';\n  }\n\n  // 직업 결정\n  let job;\n  if (id <= 9) {\n    job = 'mage';\n  } else if (id <= 18) {\n    job = 'archer';\n  } else {\n    job = 'warrior';\n  }\n\n  // 성향 결정\n  let alignment;\n  if ([1, 4, 7, 10, 13, 16, 19, 22, 25].includes(id)) {\n    alignment = 'cold';\n  } else if ([2, 5, 8, 11, 14, 17, 20, 23, 26].includes(id)) {\n    alignment = 'order';\n  } else {\n    alignment = 'chaos';\n  }\n  return {\n    race,\n    job,\n    alignment\n  };\n};\n\n// 카드 생성 함수\nexport const createCard = id => {\n  const attributes = getCardAttributes(id);\n\n  // 이미지 경로 설정 - 1자리 숫자는 01, 09 형식으로 변환\n  let imagePath;\n  if (id < 10) {\n    imagePath = `/Assets/0${id}.png`;\n  } else {\n    imagePath = `/Assets/${id}.png`;\n  }\n  return {\n    id,\n    ...attributes,\n    imagePath\n  };\n};\n\n// 사용하지 않은 카드 ID에서 무작위로 n개 선택\nexport const getRandomUnusedCardIds = (usedCardIds, count) => {\n  const allCardIds = Array.from({\n    length: 27\n  }, (_, i) => i + 1);\n  const unusedCardIds = allCardIds.filter(id => !usedCardIds.includes(id));\n\n  // 사용하지 않은 카드가 충분하지 않으면 모든 카드를 다시 사용\n  if (unusedCardIds.length < count) {\n    return [...unusedCardIds, ...shuffleArray(allCardIds).slice(0, count - unusedCardIds.length)];\n  }\n  return shuffleArray(unusedCardIds).slice(0, count);\n};\n\n// 배열 섞기 함수\nexport const shuffleArray = array => {\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n};\n\n// 보드 초기화 함수\nexport const initializeBoard = (usedCardIds = []) => {\n  const cardIds = getRandomUnusedCardIds(usedCardIds, 9);\n  return cardIds.map(id => createCard(id));\n};\n\n// 보드 갱신 함수 (선택된 카드 대체)\nexport const refreshBoard = (currentBoard, selectedCardIds, usedCardIds) => {\n  const newBoard = [...currentBoard];\n  const newCardIds = getRandomUnusedCardIds([...usedCardIds, ...selectedCardIds], selectedCardIds.length);\n\n  // 선택된 카드를 새 카드로 교체\n  selectedCardIds.forEach((selectedId, index) => {\n    const boardIndex = newBoard.findIndex(card => card.id === selectedId);\n    if (boardIndex !== -1 && index < newCardIds.length) {\n      newBoard[boardIndex] = createCard(newCardIds[index]);\n    }\n  });\n  return newBoard;\n};","map":{"version":3,"names":["compareAttributes","cards","length","isValid","message","attributes","isValidCombination","attr","values","allSame","every","v","allDifferent","Set","size","getCardAttributes","id","race","includes","job","alignment","createCard","imagePath","getRandomUnusedCardIds","usedCardIds","count","allCardIds","Array","from","_","i","unusedCardIds","filter","shuffleArray","slice","array","newArray","j","Math","floor","random","initializeBoard","cardIds","map","refreshBoard","currentBoard","selectedCardIds","newBoard","newCardIds","forEach","selectedId","index","boardIndex","findIndex","card"],"sources":["/Users/nhwm1/Desktop/TRIO/src/utils/gameLogic.ts"],"sourcesContent":["import { Card, ValidationResult, Race, Job, Alignment } from '../types/types';\n\n// 카드 속성 비교 함수\nexport const compareAttributes = (cards: Card[]): ValidationResult => {\n  if (cards.length !== 3) {\n    return {\n      isValid: false,\n      message: '3개의 카드가 필요합니다.'\n    };\n  }\n\n  const attributes: (keyof Omit<Card, 'id' | 'imagePath'>)[] = ['race', 'job', 'alignment'];\n  \n  let isValidCombination = true;\n  for (const attr of attributes) {\n    const values = [cards[0][attr], cards[1][attr], cards[2][attr]];\n    const allSame = values.every(v => v === values[0]);\n    const allDifferent = new Set(values).size === values.length;\n    \n    if (!allSame && !allDifferent) {\n      isValidCombination = false;\n      break;\n    }\n  }\n\n  return {\n    isValid: isValidCombination,\n    message: isValidCombination ? '유효한 조합입니다!' : '유효하지 않은 조합입니다.'\n  };\n};\n\n// 카드 ID로부터 속성 결정\nexport const getCardAttributes = (id: number): { race: Race; job: Job; alignment: Alignment } => {\n  // 종족 결정\n  let race: Race;\n  if ([1,2,3,10,11,12,19,20,21].includes(id)) {\n    race = 'human';\n  } else if ([4,5,6,13,14,15,22,23,24].includes(id)) {\n    race = 'elf';\n  } else {\n    race = 'dwarf';\n  }\n\n  // 직업 결정\n  let job: Job;\n  if (id <= 9) {\n    job = 'mage';\n  } else if (id <= 18) {\n    job = 'archer';\n  } else {\n    job = 'warrior';\n  }\n\n  // 성향 결정\n  let alignment: Alignment;\n  if ([1,4,7,10,13,16,19,22,25].includes(id)) {\n    alignment = 'cold';\n  } else if ([2,5,8,11,14,17,20,23,26].includes(id)) {\n    alignment = 'order';\n  } else {\n    alignment = 'chaos';\n  }\n\n  return { race, job, alignment };\n};\n\n// 카드 생성 함수\nexport const createCard = (id: number): Card => {\n  const attributes = getCardAttributes(id);\n  \n  // 이미지 경로 설정 - 1자리 숫자는 01, 09 형식으로 변환\n  let imagePath;\n  if (id < 10) {\n    imagePath = `/Assets/0${id}.png`;\n  } else {\n    imagePath = `/Assets/${id}.png`;\n  }\n  \n  return {\n    id,\n    ...attributes,\n    imagePath\n  };\n};\n\n// 사용하지 않은 카드 ID에서 무작위로 n개 선택\nexport const getRandomUnusedCardIds = (usedCardIds: number[], count: number): number[] => {\n  const allCardIds = Array.from({ length: 27 }, (_, i) => i + 1);\n  const unusedCardIds = allCardIds.filter(id => !usedCardIds.includes(id));\n  \n  // 사용하지 않은 카드가 충분하지 않으면 모든 카드를 다시 사용\n  if (unusedCardIds.length < count) {\n    return [...unusedCardIds, ...shuffleArray(allCardIds).slice(0, count - unusedCardIds.length)];\n  }\n  \n  return shuffleArray(unusedCardIds).slice(0, count);\n};\n\n// 배열 섞기 함수\nexport const shuffleArray = <T>(array: T[]): T[] => {\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n};\n\n// 보드 초기화 함수\nexport const initializeBoard = (usedCardIds: number[] = []): Card[] => {\n  const cardIds = getRandomUnusedCardIds(usedCardIds, 9);\n  return cardIds.map(id => createCard(id));\n};\n\n// 보드 갱신 함수 (선택된 카드 대체)\nexport const refreshBoard = (currentBoard: Card[], selectedCardIds: number[], usedCardIds: number[]): Card[] => {\n  const newBoard = [...currentBoard];\n  const newCardIds = getRandomUnusedCardIds([...usedCardIds, ...selectedCardIds], selectedCardIds.length);\n  \n  // 선택된 카드를 새 카드로 교체\n  selectedCardIds.forEach((selectedId, index) => {\n    const boardIndex = newBoard.findIndex(card => card.id === selectedId);\n    if (boardIndex !== -1 && index < newCardIds.length) {\n      newBoard[boardIndex] = createCard(newCardIds[index]);\n    }\n  });\n  \n  return newBoard;\n}; "],"mappings":"AAEA;AACA,OAAO,MAAMA,iBAAiB,GAAIC,KAAa,IAAuB;EACpE,IAAIA,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO;MACLC,OAAO,EAAE,KAAK;MACdC,OAAO,EAAE;IACX,CAAC;EACH;EAEA,MAAMC,UAAoD,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,WAAW,CAAC;EAEzF,IAAIC,kBAAkB,GAAG,IAAI;EAC7B,KAAK,MAAMC,IAAI,IAAIF,UAAU,EAAE;IAC7B,MAAMG,MAAM,GAAG,CAACP,KAAK,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,EAAEN,KAAK,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,EAAEN,KAAK,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC;IAC/D,MAAME,OAAO,GAAGD,MAAM,CAACE,KAAK,CAACC,CAAC,IAAIA,CAAC,KAAKH,MAAM,CAAC,CAAC,CAAC,CAAC;IAClD,MAAMI,YAAY,GAAG,IAAIC,GAAG,CAACL,MAAM,CAAC,CAACM,IAAI,KAAKN,MAAM,CAACN,MAAM;IAE3D,IAAI,CAACO,OAAO,IAAI,CAACG,YAAY,EAAE;MAC7BN,kBAAkB,GAAG,KAAK;MAC1B;IACF;EACF;EAEA,OAAO;IACLH,OAAO,EAAEG,kBAAkB;IAC3BF,OAAO,EAAEE,kBAAkB,GAAG,YAAY,GAAG;EAC/C,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMS,iBAAiB,GAAIC,EAAU,IAAqD;EAC/F;EACA,IAAIC,IAAU;EACd,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACC,QAAQ,CAACF,EAAE,CAAC,EAAE;IAC1CC,IAAI,GAAG,OAAO;EAChB,CAAC,MAAM,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACC,QAAQ,CAACF,EAAE,CAAC,EAAE;IACjDC,IAAI,GAAG,KAAK;EACd,CAAC,MAAM;IACLA,IAAI,GAAG,OAAO;EAChB;;EAEA;EACA,IAAIE,GAAQ;EACZ,IAAIH,EAAE,IAAI,CAAC,EAAE;IACXG,GAAG,GAAG,MAAM;EACd,CAAC,MAAM,IAAIH,EAAE,IAAI,EAAE,EAAE;IACnBG,GAAG,GAAG,QAAQ;EAChB,CAAC,MAAM;IACLA,GAAG,GAAG,SAAS;EACjB;;EAEA;EACA,IAAIC,SAAoB;EACxB,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACF,QAAQ,CAACF,EAAE,CAAC,EAAE;IAC1CI,SAAS,GAAG,MAAM;EACpB,CAAC,MAAM,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACF,QAAQ,CAACF,EAAE,CAAC,EAAE;IACjDI,SAAS,GAAG,OAAO;EACrB,CAAC,MAAM;IACLA,SAAS,GAAG,OAAO;EACrB;EAEA,OAAO;IAAEH,IAAI;IAAEE,GAAG;IAAEC;EAAU,CAAC;AACjC,CAAC;;AAED;AACA,OAAO,MAAMC,UAAU,GAAIL,EAAU,IAAW;EAC9C,MAAMX,UAAU,GAAGU,iBAAiB,CAACC,EAAE,CAAC;;EAExC;EACA,IAAIM,SAAS;EACb,IAAIN,EAAE,GAAG,EAAE,EAAE;IACXM,SAAS,GAAG,YAAYN,EAAE,MAAM;EAClC,CAAC,MAAM;IACLM,SAAS,GAAG,WAAWN,EAAE,MAAM;EACjC;EAEA,OAAO;IACLA,EAAE;IACF,GAAGX,UAAU;IACbiB;EACF,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAACC,WAAqB,EAAEC,KAAa,KAAe;EACxF,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAE1B,MAAM,EAAE;EAAG,CAAC,EAAE,CAAC2B,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAG,CAAC,CAAC;EAC9D,MAAMC,aAAa,GAAGL,UAAU,CAACM,MAAM,CAAChB,EAAE,IAAI,CAACQ,WAAW,CAACN,QAAQ,CAACF,EAAE,CAAC,CAAC;;EAExE;EACA,IAAIe,aAAa,CAAC7B,MAAM,GAAGuB,KAAK,EAAE;IAChC,OAAO,CAAC,GAAGM,aAAa,EAAE,GAAGE,YAAY,CAACP,UAAU,CAAC,CAACQ,KAAK,CAAC,CAAC,EAAET,KAAK,GAAGM,aAAa,CAAC7B,MAAM,CAAC,CAAC;EAC/F;EAEA,OAAO+B,YAAY,CAACF,aAAa,CAAC,CAACG,KAAK,CAAC,CAAC,EAAET,KAAK,CAAC;AACpD,CAAC;;AAED;AACA,OAAO,MAAMQ,YAAY,GAAOE,KAAU,IAAU;EAClD,MAAMC,QAAQ,GAAG,CAAC,GAAGD,KAAK,CAAC;EAC3B,KAAK,IAAIL,CAAC,GAAGM,QAAQ,CAAClC,MAAM,GAAG,CAAC,EAAE4B,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC5C,MAAMO,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIV,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,CAACM,QAAQ,CAACN,CAAC,CAAC,EAAEM,QAAQ,CAACC,CAAC,CAAC,CAAC,GAAG,CAACD,QAAQ,CAACC,CAAC,CAAC,EAAED,QAAQ,CAACN,CAAC,CAAC,CAAC;EACzD;EACA,OAAOM,QAAQ;AACjB,CAAC;;AAED;AACA,OAAO,MAAMK,eAAe,GAAGA,CAACjB,WAAqB,GAAG,EAAE,KAAa;EACrE,MAAMkB,OAAO,GAAGnB,sBAAsB,CAACC,WAAW,EAAE,CAAC,CAAC;EACtD,OAAOkB,OAAO,CAACC,GAAG,CAAC3B,EAAE,IAAIK,UAAU,CAACL,EAAE,CAAC,CAAC;AAC1C,CAAC;;AAED;AACA,OAAO,MAAM4B,YAAY,GAAGA,CAACC,YAAoB,EAAEC,eAAyB,EAAEtB,WAAqB,KAAa;EAC9G,MAAMuB,QAAQ,GAAG,CAAC,GAAGF,YAAY,CAAC;EAClC,MAAMG,UAAU,GAAGzB,sBAAsB,CAAC,CAAC,GAAGC,WAAW,EAAE,GAAGsB,eAAe,CAAC,EAAEA,eAAe,CAAC5C,MAAM,CAAC;;EAEvG;EACA4C,eAAe,CAACG,OAAO,CAAC,CAACC,UAAU,EAAEC,KAAK,KAAK;IAC7C,MAAMC,UAAU,GAAGL,QAAQ,CAACM,SAAS,CAACC,IAAI,IAAIA,IAAI,CAACtC,EAAE,KAAKkC,UAAU,CAAC;IACrE,IAAIE,UAAU,KAAK,CAAC,CAAC,IAAID,KAAK,GAAGH,UAAU,CAAC9C,MAAM,EAAE;MAClD6C,QAAQ,CAACK,UAAU,CAAC,GAAG/B,UAAU,CAAC2B,UAAU,CAACG,KAAK,CAAC,CAAC;IACtD;EACF,CAAC,CAAC;EAEF,OAAOJ,QAAQ;AACjB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}