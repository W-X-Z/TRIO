{"ast":null,"code":"// 카드 속성 비교 함수\nexport const compareAttributes = cards => {\n  if (cards.length !== 3) {\n    return {\n      isValid: false,\n      message: '3개의 카드가 필요합니다.'\n    };\n  }\n  const attributes = ['race', 'job', 'alignment'];\n  let isValidCombination = true;\n  for (const attr of attributes) {\n    const values = [cards[0][attr], cards[1][attr], cards[2][attr]];\n    const allSame = values.every(v => v === values[0]);\n    const allDifferent = new Set(values).size === values.length;\n    if (!allSame && !allDifferent) {\n      isValidCombination = false;\n      break;\n    }\n  }\n  return {\n    isValid: isValidCombination,\n    message: isValidCombination ? '유효한 조합입니다!' : '유효하지 않은 조합입니다.'\n  };\n};\n\n// 카드 ID로부터 속성 결정\nexport const getCardAttributes = id => {\n  // 종족 결정\n  let race;\n  if ([1, 2, 3, 10, 11, 12, 19, 20, 21].includes(id)) {\n    race = 'human';\n  } else if ([4, 5, 6, 13, 14, 15, 22, 23, 24].includes(id)) {\n    race = 'elf';\n  } else {\n    race = 'dwarf';\n  }\n\n  // 직업 결정\n  let job;\n  if (id <= 9) {\n    job = 'mage';\n  } else if (id <= 18) {\n    job = 'archer';\n  } else {\n    job = 'warrior';\n  }\n\n  // 성향 결정\n  let alignment;\n  if ([1, 4, 7, 10, 13, 16, 19, 22, 25].includes(id)) {\n    alignment = 'cold';\n  } else if ([2, 5, 8, 11, 14, 17, 20, 23, 26].includes(id)) {\n    alignment = 'order';\n  } else {\n    alignment = 'chaos';\n  }\n  return {\n    race,\n    job,\n    alignment\n  };\n};\n\n// 카드 생성 함수\nexport const createCard = id => {\n  const attributes = getCardAttributes(id);\n\n  // 이미지 경로 설정 - 1자리 숫자는 01, 09 형식으로 변환\n  let imagePath;\n  if (id < 10) {\n    imagePath = `/Assets/0${id}.png`;\n  } else {\n    imagePath = `/Assets/${id}.png`;\n  }\n  return {\n    id,\n    ...attributes,\n    imagePath\n  };\n};\n\n// 사용하지 않은 카드 ID에서 무작위로 n개 선택\nexport const getRandomUnusedCardIds = (usedCardIds, count, excludeIds = []) => {\n  const allCardIds = Array.from({\n    length: 27\n  }, (_, i) => i + 1);\n\n  // 이미 사용된 카드와 제외할 카드 ID를 필터링\n  const unusedCardIds = allCardIds.filter(id => !usedCardIds.includes(id) && !excludeIds.includes(id));\n\n  // 사용하지 않은 카드가 충분하지 않으면 모든 카드를 다시 사용\n  if (unusedCardIds.length < count) {\n    console.warn('사용 가능한 카드가 부족합니다. 모든 카드를 다시 사용합니다.');\n    return shuffleArray(allCardIds.filter(id => !excludeIds.includes(id))).slice(0, count);\n  }\n  return shuffleArray(unusedCardIds).slice(0, count);\n};\n\n// 배열 섞기 함수\nexport const shuffleArray = array => {\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n};\n\n// 보드 초기화 함수\nexport const initializeBoard = (usedCardIds = []) => {\n  // 모든 가능한 카드 ID 중에서 중복 없이 9개 선택\n  const allCardIds = Array.from({\n    length: 27\n  }, (_, i) => i + 1);\n  const availableCardIds = allCardIds.filter(id => !usedCardIds.includes(id));\n  if (availableCardIds.length < 9) {\n    console.warn('사용 가능한 카드가 9개 미만입니다. 모든 카드를 다시 사용합니다.');\n    // 카드가 부족하면 전체에서 랜덤하게 9개 선택\n    return shuffleArray(allCardIds).slice(0, 9).map(id => createCard(id));\n  }\n\n  // 사용 가능한 카드 중에서 9개 선택\n  const cardIds = shuffleArray(availableCardIds).slice(0, 9);\n\n  // 중복 확인\n  const uniqueCardIds = new Set(cardIds);\n  if (uniqueCardIds.size !== 9) {\n    console.error('중복된 카드가 선택되었습니다!', cardIds);\n  }\n  return cardIds.map(id => createCard(id));\n};\n\n// 보드 갱신 함수 (선택된 카드 대체)\nexport const refreshBoard = (currentBoard, selectedCardIds, usedCardIds) => {\n  const newBoard = [...currentBoard];\n\n  // 현재 보드에 있는 모든 카드 ID (중복 방지용)\n  const currentBoardIds = newBoard.map(card => card.id).filter(id => !selectedCardIds.includes(id));\n\n  // 새로운 카드를 선택할 때 현재 보드에 있는 카드는 제외\n  const newCardIds = getRandomUnusedCardIds(usedCardIds, selectedCardIds.length, currentBoardIds);\n\n  // 중복 확인\n  const uniqueNewCardIds = new Set(newCardIds);\n  if (uniqueNewCardIds.size !== selectedCardIds.length) {\n    console.error('중복된 새 카드가 선택되었습니다!', newCardIds);\n  }\n\n  // 선택된 카드를 새 카드로 교체\n  selectedCardIds.forEach((selectedId, index) => {\n    const boardIndex = newBoard.findIndex(card => card.id === selectedId);\n    if (boardIndex !== -1 && index < newCardIds.length) {\n      newBoard[boardIndex] = createCard(newCardIds[index]);\n    }\n  });\n\n  // 최종 보드의 카드들이 중복되지 않는지 확인\n  const finalBoardIds = newBoard.map(card => card.id);\n  const uniqueIds = new Set(finalBoardIds);\n  if (uniqueIds.size !== finalBoardIds.length) {\n    console.error('최종 보드에 중복된 카드가 있습니다!', finalBoardIds);\n\n    // 중복 수정: 중복된 카드 찾아서 새 카드로 교체\n    const duplicates = finalBoardIds.filter((id, index) => finalBoardIds.indexOf(id) !== index);\n    if (duplicates.length > 0) {\n      console.warn('중복 카드를 새 카드로 교체합니다:', duplicates);\n\n      // 중복된 카드의 두 번째 등장부터 교체\n      duplicates.forEach(dupId => {\n        const firstIndex = finalBoardIds.indexOf(dupId);\n        const secondIndex = finalBoardIds.indexOf(dupId, firstIndex + 1);\n        if (secondIndex !== -1) {\n          // 중복되지 않는 새 카드 ID 찾기\n          const allIds = Array.from({\n            length: 27\n          }, (_, i) => i + 1);\n          const availableIds = allIds.filter(id => !finalBoardIds.includes(id) && !usedCardIds.includes(id));\n          if (availableIds.length > 0) {\n            const newId = availableIds[0];\n            newBoard[secondIndex] = createCard(newId);\n            finalBoardIds[secondIndex] = newId;\n          }\n        }\n      });\n    }\n  }\n  return newBoard;\n};","map":{"version":3,"names":["compareAttributes","cards","length","isValid","message","attributes","isValidCombination","attr","values","allSame","every","v","allDifferent","Set","size","getCardAttributes","id","race","includes","job","alignment","createCard","imagePath","getRandomUnusedCardIds","usedCardIds","count","excludeIds","allCardIds","Array","from","_","i","unusedCardIds","filter","console","warn","shuffleArray","slice","array","newArray","j","Math","floor","random","initializeBoard","availableCardIds","map","cardIds","uniqueCardIds","error","refreshBoard","currentBoard","selectedCardIds","newBoard","currentBoardIds","card","newCardIds","uniqueNewCardIds","forEach","selectedId","index","boardIndex","findIndex","finalBoardIds","uniqueIds","duplicates","indexOf","dupId","firstIndex","secondIndex","allIds","availableIds","newId"],"sources":["/Users/nhwm1/Desktop/TRIO/src/utils/gameLogic.ts"],"sourcesContent":["import { Card, ValidationResult, Race, Job, Alignment } from '../types/types';\n\n// 카드 속성 비교 함수\nexport const compareAttributes = (cards: Card[]): ValidationResult => {\n  if (cards.length !== 3) {\n    return {\n      isValid: false,\n      message: '3개의 카드가 필요합니다.'\n    };\n  }\n\n  const attributes: (keyof Omit<Card, 'id' | 'imagePath'>)[] = ['race', 'job', 'alignment'];\n  \n  let isValidCombination = true;\n  for (const attr of attributes) {\n    const values = [cards[0][attr], cards[1][attr], cards[2][attr]];\n    const allSame = values.every(v => v === values[0]);\n    const allDifferent = new Set(values).size === values.length;\n    \n    if (!allSame && !allDifferent) {\n      isValidCombination = false;\n      break;\n    }\n  }\n\n  return {\n    isValid: isValidCombination,\n    message: isValidCombination ? '유효한 조합입니다!' : '유효하지 않은 조합입니다.'\n  };\n};\n\n// 카드 ID로부터 속성 결정\nexport const getCardAttributes = (id: number): { race: Race; job: Job; alignment: Alignment } => {\n  // 종족 결정\n  let race: Race;\n  if ([1,2,3,10,11,12,19,20,21].includes(id)) {\n    race = 'human';\n  } else if ([4,5,6,13,14,15,22,23,24].includes(id)) {\n    race = 'elf';\n  } else {\n    race = 'dwarf';\n  }\n\n  // 직업 결정\n  let job: Job;\n  if (id <= 9) {\n    job = 'mage';\n  } else if (id <= 18) {\n    job = 'archer';\n  } else {\n    job = 'warrior';\n  }\n\n  // 성향 결정\n  let alignment: Alignment;\n  if ([1,4,7,10,13,16,19,22,25].includes(id)) {\n    alignment = 'cold';\n  } else if ([2,5,8,11,14,17,20,23,26].includes(id)) {\n    alignment = 'order';\n  } else {\n    alignment = 'chaos';\n  }\n\n  return { race, job, alignment };\n};\n\n// 카드 생성 함수\nexport const createCard = (id: number): Card => {\n  const attributes = getCardAttributes(id);\n  \n  // 이미지 경로 설정 - 1자리 숫자는 01, 09 형식으로 변환\n  let imagePath;\n  if (id < 10) {\n    imagePath = `/Assets/0${id}.png`;\n  } else {\n    imagePath = `/Assets/${id}.png`;\n  }\n  \n  return {\n    id,\n    ...attributes,\n    imagePath\n  };\n};\n\n// 사용하지 않은 카드 ID에서 무작위로 n개 선택\nexport const getRandomUnusedCardIds = (usedCardIds: number[], count: number, excludeIds: number[] = []): number[] => {\n  const allCardIds = Array.from({ length: 27 }, (_, i) => i + 1);\n  \n  // 이미 사용된 카드와 제외할 카드 ID를 필터링\n  const unusedCardIds = allCardIds.filter(id => \n    !usedCardIds.includes(id) && !excludeIds.includes(id)\n  );\n  \n  // 사용하지 않은 카드가 충분하지 않으면 모든 카드를 다시 사용\n  if (unusedCardIds.length < count) {\n    console.warn('사용 가능한 카드가 부족합니다. 모든 카드를 다시 사용합니다.');\n    return shuffleArray(\n      allCardIds.filter(id => !excludeIds.includes(id))\n    ).slice(0, count);\n  }\n  \n  return shuffleArray(unusedCardIds).slice(0, count);\n};\n\n// 배열 섞기 함수\nexport const shuffleArray = <T>(array: T[]): T[] => {\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n};\n\n// 보드 초기화 함수\nexport const initializeBoard = (usedCardIds: number[] = []): Card[] => {\n  // 모든 가능한 카드 ID 중에서 중복 없이 9개 선택\n  const allCardIds = Array.from({ length: 27 }, (_, i) => i + 1);\n  const availableCardIds = allCardIds.filter(id => !usedCardIds.includes(id));\n  \n  if (availableCardIds.length < 9) {\n    console.warn('사용 가능한 카드가 9개 미만입니다. 모든 카드를 다시 사용합니다.');\n    // 카드가 부족하면 전체에서 랜덤하게 9개 선택\n    return shuffleArray(allCardIds).slice(0, 9).map(id => createCard(id));\n  }\n  \n  // 사용 가능한 카드 중에서 9개 선택\n  const cardIds = shuffleArray(availableCardIds).slice(0, 9);\n  \n  // 중복 확인\n  const uniqueCardIds = new Set(cardIds);\n  if (uniqueCardIds.size !== 9) {\n    console.error('중복된 카드가 선택되었습니다!', cardIds);\n  }\n  \n  return cardIds.map(id => createCard(id));\n};\n\n// 보드 갱신 함수 (선택된 카드 대체)\nexport const refreshBoard = (currentBoard: Card[], selectedCardIds: number[], usedCardIds: number[]): Card[] => {\n  const newBoard = [...currentBoard];\n  \n  // 현재 보드에 있는 모든 카드 ID (중복 방지용)\n  const currentBoardIds = newBoard.map(card => card.id).filter(id => !selectedCardIds.includes(id));\n  \n  // 새로운 카드를 선택할 때 현재 보드에 있는 카드는 제외\n  const newCardIds = getRandomUnusedCardIds(usedCardIds, selectedCardIds.length, currentBoardIds);\n  \n  // 중복 확인\n  const uniqueNewCardIds = new Set(newCardIds);\n  if (uniqueNewCardIds.size !== selectedCardIds.length) {\n    console.error('중복된 새 카드가 선택되었습니다!', newCardIds);\n  }\n  \n  // 선택된 카드를 새 카드로 교체\n  selectedCardIds.forEach((selectedId, index) => {\n    const boardIndex = newBoard.findIndex(card => card.id === selectedId);\n    if (boardIndex !== -1 && index < newCardIds.length) {\n      newBoard[boardIndex] = createCard(newCardIds[index]);\n    }\n  });\n  \n  // 최종 보드의 카드들이 중복되지 않는지 확인\n  const finalBoardIds = newBoard.map(card => card.id);\n  const uniqueIds = new Set(finalBoardIds);\n  \n  if (uniqueIds.size !== finalBoardIds.length) {\n    console.error('최종 보드에 중복된 카드가 있습니다!', finalBoardIds);\n    \n    // 중복 수정: 중복된 카드 찾아서 새 카드로 교체\n    const duplicates = finalBoardIds.filter((id, index) => finalBoardIds.indexOf(id) !== index);\n    if (duplicates.length > 0) {\n      console.warn('중복 카드를 새 카드로 교체합니다:', duplicates);\n      \n      // 중복된 카드의 두 번째 등장부터 교체\n      duplicates.forEach(dupId => {\n        const firstIndex = finalBoardIds.indexOf(dupId);\n        const secondIndex = finalBoardIds.indexOf(dupId, firstIndex + 1);\n        \n        if (secondIndex !== -1) {\n          // 중복되지 않는 새 카드 ID 찾기\n          const allIds = Array.from({ length: 27 }, (_, i) => i + 1);\n          const availableIds = allIds.filter(id => !finalBoardIds.includes(id) && !usedCardIds.includes(id));\n          \n          if (availableIds.length > 0) {\n            const newId = availableIds[0];\n            newBoard[secondIndex] = createCard(newId);\n            finalBoardIds[secondIndex] = newId;\n          }\n        }\n      });\n    }\n  }\n  \n  return newBoard;\n}; "],"mappings":"AAEA;AACA,OAAO,MAAMA,iBAAiB,GAAIC,KAAa,IAAuB;EACpE,IAAIA,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO;MACLC,OAAO,EAAE,KAAK;MACdC,OAAO,EAAE;IACX,CAAC;EACH;EAEA,MAAMC,UAAoD,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,WAAW,CAAC;EAEzF,IAAIC,kBAAkB,GAAG,IAAI;EAC7B,KAAK,MAAMC,IAAI,IAAIF,UAAU,EAAE;IAC7B,MAAMG,MAAM,GAAG,CAACP,KAAK,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,EAAEN,KAAK,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,EAAEN,KAAK,CAAC,CAAC,CAAC,CAACM,IAAI,CAAC,CAAC;IAC/D,MAAME,OAAO,GAAGD,MAAM,CAACE,KAAK,CAACC,CAAC,IAAIA,CAAC,KAAKH,MAAM,CAAC,CAAC,CAAC,CAAC;IAClD,MAAMI,YAAY,GAAG,IAAIC,GAAG,CAACL,MAAM,CAAC,CAACM,IAAI,KAAKN,MAAM,CAACN,MAAM;IAE3D,IAAI,CAACO,OAAO,IAAI,CAACG,YAAY,EAAE;MAC7BN,kBAAkB,GAAG,KAAK;MAC1B;IACF;EACF;EAEA,OAAO;IACLH,OAAO,EAAEG,kBAAkB;IAC3BF,OAAO,EAAEE,kBAAkB,GAAG,YAAY,GAAG;EAC/C,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMS,iBAAiB,GAAIC,EAAU,IAAqD;EAC/F;EACA,IAAIC,IAAU;EACd,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACC,QAAQ,CAACF,EAAE,CAAC,EAAE;IAC1CC,IAAI,GAAG,OAAO;EAChB,CAAC,MAAM,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACC,QAAQ,CAACF,EAAE,CAAC,EAAE;IACjDC,IAAI,GAAG,KAAK;EACd,CAAC,MAAM;IACLA,IAAI,GAAG,OAAO;EAChB;;EAEA;EACA,IAAIE,GAAQ;EACZ,IAAIH,EAAE,IAAI,CAAC,EAAE;IACXG,GAAG,GAAG,MAAM;EACd,CAAC,MAAM,IAAIH,EAAE,IAAI,EAAE,EAAE;IACnBG,GAAG,GAAG,QAAQ;EAChB,CAAC,MAAM;IACLA,GAAG,GAAG,SAAS;EACjB;;EAEA;EACA,IAAIC,SAAoB;EACxB,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACF,QAAQ,CAACF,EAAE,CAAC,EAAE;IAC1CI,SAAS,GAAG,MAAM;EACpB,CAAC,MAAM,IAAI,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC,CAACF,QAAQ,CAACF,EAAE,CAAC,EAAE;IACjDI,SAAS,GAAG,OAAO;EACrB,CAAC,MAAM;IACLA,SAAS,GAAG,OAAO;EACrB;EAEA,OAAO;IAAEH,IAAI;IAAEE,GAAG;IAAEC;EAAU,CAAC;AACjC,CAAC;;AAED;AACA,OAAO,MAAMC,UAAU,GAAIL,EAAU,IAAW;EAC9C,MAAMX,UAAU,GAAGU,iBAAiB,CAACC,EAAE,CAAC;;EAExC;EACA,IAAIM,SAAS;EACb,IAAIN,EAAE,GAAG,EAAE,EAAE;IACXM,SAAS,GAAG,YAAYN,EAAE,MAAM;EAClC,CAAC,MAAM;IACLM,SAAS,GAAG,WAAWN,EAAE,MAAM;EACjC;EAEA,OAAO;IACLA,EAAE;IACF,GAAGX,UAAU;IACbiB;EACF,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAACC,WAAqB,EAAEC,KAAa,EAAEC,UAAoB,GAAG,EAAE,KAAe;EACnH,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAE3B,MAAM,EAAE;EAAG,CAAC,EAAE,CAAC4B,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAG,CAAC,CAAC;;EAE9D;EACA,MAAMC,aAAa,GAAGL,UAAU,CAACM,MAAM,CAACjB,EAAE,IACxC,CAACQ,WAAW,CAACN,QAAQ,CAACF,EAAE,CAAC,IAAI,CAACU,UAAU,CAACR,QAAQ,CAACF,EAAE,CACtD,CAAC;;EAED;EACA,IAAIgB,aAAa,CAAC9B,MAAM,GAAGuB,KAAK,EAAE;IAChCS,OAAO,CAACC,IAAI,CAAC,oCAAoC,CAAC;IAClD,OAAOC,YAAY,CACjBT,UAAU,CAACM,MAAM,CAACjB,EAAE,IAAI,CAACU,UAAU,CAACR,QAAQ,CAACF,EAAE,CAAC,CAClD,CAAC,CAACqB,KAAK,CAAC,CAAC,EAAEZ,KAAK,CAAC;EACnB;EAEA,OAAOW,YAAY,CAACJ,aAAa,CAAC,CAACK,KAAK,CAAC,CAAC,EAAEZ,KAAK,CAAC;AACpD,CAAC;;AAED;AACA,OAAO,MAAMW,YAAY,GAAOE,KAAU,IAAU;EAClD,MAAMC,QAAQ,GAAG,CAAC,GAAGD,KAAK,CAAC;EAC3B,KAAK,IAAIP,CAAC,GAAGQ,QAAQ,CAACrC,MAAM,GAAG,CAAC,EAAE6B,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC5C,MAAMS,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIZ,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,CAACQ,QAAQ,CAACR,CAAC,CAAC,EAAEQ,QAAQ,CAACC,CAAC,CAAC,CAAC,GAAG,CAACD,QAAQ,CAACC,CAAC,CAAC,EAAED,QAAQ,CAACR,CAAC,CAAC,CAAC;EACzD;EACA,OAAOQ,QAAQ;AACjB,CAAC;;AAED;AACA,OAAO,MAAMK,eAAe,GAAGA,CAACpB,WAAqB,GAAG,EAAE,KAAa;EACrE;EACA,MAAMG,UAAU,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAE3B,MAAM,EAAE;EAAG,CAAC,EAAE,CAAC4B,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAG,CAAC,CAAC;EAC9D,MAAMc,gBAAgB,GAAGlB,UAAU,CAACM,MAAM,CAACjB,EAAE,IAAI,CAACQ,WAAW,CAACN,QAAQ,CAACF,EAAE,CAAC,CAAC;EAE3E,IAAI6B,gBAAgB,CAAC3C,MAAM,GAAG,CAAC,EAAE;IAC/BgC,OAAO,CAACC,IAAI,CAAC,uCAAuC,CAAC;IACrD;IACA,OAAOC,YAAY,CAACT,UAAU,CAAC,CAACU,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAACS,GAAG,CAAC9B,EAAE,IAAIK,UAAU,CAACL,EAAE,CAAC,CAAC;EACvE;;EAEA;EACA,MAAM+B,OAAO,GAAGX,YAAY,CAACS,gBAAgB,CAAC,CAACR,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;;EAE1D;EACA,MAAMW,aAAa,GAAG,IAAInC,GAAG,CAACkC,OAAO,CAAC;EACtC,IAAIC,aAAa,CAAClC,IAAI,KAAK,CAAC,EAAE;IAC5BoB,OAAO,CAACe,KAAK,CAAC,kBAAkB,EAAEF,OAAO,CAAC;EAC5C;EAEA,OAAOA,OAAO,CAACD,GAAG,CAAC9B,EAAE,IAAIK,UAAU,CAACL,EAAE,CAAC,CAAC;AAC1C,CAAC;;AAED;AACA,OAAO,MAAMkC,YAAY,GAAGA,CAACC,YAAoB,EAAEC,eAAyB,EAAE5B,WAAqB,KAAa;EAC9G,MAAM6B,QAAQ,GAAG,CAAC,GAAGF,YAAY,CAAC;;EAElC;EACA,MAAMG,eAAe,GAAGD,QAAQ,CAACP,GAAG,CAACS,IAAI,IAAIA,IAAI,CAACvC,EAAE,CAAC,CAACiB,MAAM,CAACjB,EAAE,IAAI,CAACoC,eAAe,CAAClC,QAAQ,CAACF,EAAE,CAAC,CAAC;;EAEjG;EACA,MAAMwC,UAAU,GAAGjC,sBAAsB,CAACC,WAAW,EAAE4B,eAAe,CAAClD,MAAM,EAAEoD,eAAe,CAAC;;EAE/F;EACA,MAAMG,gBAAgB,GAAG,IAAI5C,GAAG,CAAC2C,UAAU,CAAC;EAC5C,IAAIC,gBAAgB,CAAC3C,IAAI,KAAKsC,eAAe,CAAClD,MAAM,EAAE;IACpDgC,OAAO,CAACe,KAAK,CAAC,oBAAoB,EAAEO,UAAU,CAAC;EACjD;;EAEA;EACAJ,eAAe,CAACM,OAAO,CAAC,CAACC,UAAU,EAAEC,KAAK,KAAK;IAC7C,MAAMC,UAAU,GAAGR,QAAQ,CAACS,SAAS,CAACP,IAAI,IAAIA,IAAI,CAACvC,EAAE,KAAK2C,UAAU,CAAC;IACrE,IAAIE,UAAU,KAAK,CAAC,CAAC,IAAID,KAAK,GAAGJ,UAAU,CAACtD,MAAM,EAAE;MAClDmD,QAAQ,CAACQ,UAAU,CAAC,GAAGxC,UAAU,CAACmC,UAAU,CAACI,KAAK,CAAC,CAAC;IACtD;EACF,CAAC,CAAC;;EAEF;EACA,MAAMG,aAAa,GAAGV,QAAQ,CAACP,GAAG,CAACS,IAAI,IAAIA,IAAI,CAACvC,EAAE,CAAC;EACnD,MAAMgD,SAAS,GAAG,IAAInD,GAAG,CAACkD,aAAa,CAAC;EAExC,IAAIC,SAAS,CAAClD,IAAI,KAAKiD,aAAa,CAAC7D,MAAM,EAAE;IAC3CgC,OAAO,CAACe,KAAK,CAAC,sBAAsB,EAAEc,aAAa,CAAC;;IAEpD;IACA,MAAME,UAAU,GAAGF,aAAa,CAAC9B,MAAM,CAAC,CAACjB,EAAE,EAAE4C,KAAK,KAAKG,aAAa,CAACG,OAAO,CAAClD,EAAE,CAAC,KAAK4C,KAAK,CAAC;IAC3F,IAAIK,UAAU,CAAC/D,MAAM,GAAG,CAAC,EAAE;MACzBgC,OAAO,CAACC,IAAI,CAAC,qBAAqB,EAAE8B,UAAU,CAAC;;MAE/C;MACAA,UAAU,CAACP,OAAO,CAACS,KAAK,IAAI;QAC1B,MAAMC,UAAU,GAAGL,aAAa,CAACG,OAAO,CAACC,KAAK,CAAC;QAC/C,MAAME,WAAW,GAAGN,aAAa,CAACG,OAAO,CAACC,KAAK,EAAEC,UAAU,GAAG,CAAC,CAAC;QAEhE,IAAIC,WAAW,KAAK,CAAC,CAAC,EAAE;UACtB;UACA,MAAMC,MAAM,GAAG1C,KAAK,CAACC,IAAI,CAAC;YAAE3B,MAAM,EAAE;UAAG,CAAC,EAAE,CAAC4B,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAG,CAAC,CAAC;UAC1D,MAAMwC,YAAY,GAAGD,MAAM,CAACrC,MAAM,CAACjB,EAAE,IAAI,CAAC+C,aAAa,CAAC7C,QAAQ,CAACF,EAAE,CAAC,IAAI,CAACQ,WAAW,CAACN,QAAQ,CAACF,EAAE,CAAC,CAAC;UAElG,IAAIuD,YAAY,CAACrE,MAAM,GAAG,CAAC,EAAE;YAC3B,MAAMsE,KAAK,GAAGD,YAAY,CAAC,CAAC,CAAC;YAC7BlB,QAAQ,CAACgB,WAAW,CAAC,GAAGhD,UAAU,CAACmD,KAAK,CAAC;YACzCT,aAAa,CAACM,WAAW,CAAC,GAAGG,KAAK;UACpC;QACF;MACF,CAAC,CAAC;IACJ;EACF;EAEA,OAAOnB,QAAQ;AACjB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}